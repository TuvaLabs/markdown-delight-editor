<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="markdown-delight-editor-import.html">

<dom-module id="markdown-delight-editor">
    <template>
    <style>
    :host {
        display: block;
        margin: 10px;
        background-color: #fff;
    }
    .mde-wrapper {
        height: 300px;
        border: 1px solid #ddd;
        overflow: hidden;
    }
    .mde-wrapper.full-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #fff;
        z-index: 1000;
        height: auto;
    }
    .mde-wrapper.show-preview .editor-area {
        width: 50%;
        float: left;
        border-right:1px solid #ddd;
        height: 100%;
    }
    .mde-wrapper.show-preview .CodeMirror {
        height: 100%;
    }
    .preview-area {
        display: none;
        overflow: auto;
        height: 100%;
    }
    .mde-wrapper.show-preview .preview-area {
        display: inline-block;
        width:50%;
        float:right;
    }
    .editor-area {
        box-sizing: border-box;
    }
    .preview-area
    {
        box-sizing: border-box;
        padding: 10px;
    }

    .toolbar {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        height: 46px;
        border-bottom: 1px solid #ddd;
    }
    .editor-wrapper {
        height: calc(100% - 46px);
    }
    .mde-wrapper.full-screen .editor-wrapper {
        position: fixed;
        top: 48px;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #fff;
        z-index: 1001;
        height: auto;
    }
    .editor-wrapper > ::content .CodeMirror, .editor-wrapper .editor-area {
        height: 100%;
    }
    .toolbar ::content > ul:first-child {
        border: none;
    }
    .toolbar ::content > ul {
        display: inline-block;
        list-style: none;
        padding: 8px !important;
        margin: 0 !important;
        border-left: 1px solid #ddd;
    }
    .toolbar ::content > ul li {
        display: inline-block;
    }
    .toolbar ::content > ul li a {
        padding: 6px;
        cursor: pointer;
        text-decoration: none;
        border: 1px solid transparent;
        font-size: 16px;
    }
    .toolbar ::content > ul li a:hover, .toolbar ::content > ul li a.active {
        border-color: #A7A2A2;
        border-radius: 5px;
    }
    </style>
    <div class$="mde-wrapper {{fullScreenView}} {{showPreview}}">
        <div class="toolbar">
            <ul>
                <li><a class="fa fa-bold" on-tap="handleBold" title="Bold"></a></li>
                <li><a class="fa fa-italic" on-tap="handleItalic" title="Italic"></a></li>
                <li><a class="fa fa-header" on-tap="handleHeading" title="Header"></a></li>
                <li><a class="fa fa-quote-left" on-tap="handleQuote" title="Quote"></a></li>
                <li><a class="fa fa-list-ul" on-tap="handleUl" title="Unordered List"></a></li>
                <li><a class="fa fa-list-ol" on-tap="handleOl" title="Ordered List"></a></li>
            </ul>
            <ul>
                <li><a class="fa fa-link" on-tap="handleLink" title="Link"></a></li>
                <li><a class="fa fa fa-picture-o" on-tap="handleImage" title="Image"></a></li>
            </ul>
            <ul>
                <li><a class="fa fa-columns" on-tap="handlePreview" title="Preview"></a></li>
                <li><a class="fa fa-expand" on-tap="handleExpandOrCollapse" title="Toggle Full Screen"></a></li>
            </ul>
            <content select="ul"></content>
        </div>
        <div class="editor-wrapper">
            <div class="editor-area">
                <!-- <textarea name="{{name}}"></textarea> -->
                <content select="textarea"></content>
            </div>
            <div class="preview-area" id="preview">
                Preview Area
            </div>
            <div style="clear:both"></div>
        </div>
    </div>
</template>
<script>
(function () {
    Polymer({
        is: "markdown-delight-editor",
        properties: {
            extension: String
        },
        //TODO Figure out some other way to handle the dynamic value change on the text area
        ready: function() {
            var self = this;
            setTimeout(function () {
                self.readyTemp();
            }, 100);

            // For markdown extension
            var options = {};
            if(this.extension) {
                options.extensions = [this.extension];
            }
            this.markdownConverter = new showdown.Converter(options);

            // Create the keydown event handler
            this._keydownEventHandler = this._onCaptureKeyDown.bind(this);
        },
        updatePreview: function() {
            var html = "";
            if(this.showPreview) {
                html = this.markdownConverter.makeHtml(this.querySelector('textarea').value);
            }
            this.$.preview.innerHTML = html;
        },
        readyTemp: function() {
            var textArea = this.querySelector('textarea'),
            previewArea = this.$.preview,
            self = this;

            // Initialise the codemirror
            var codemirror = CodeMirror.fromTextArea(textArea);
            codemirror.on('change', function() {
                // Update the textarea when the codemirror content gets updated
                textArea.value = codemirror.getValue();
                self.updatePreview();
            });
            this.codemirror = codemirror;

            var cm = this.codemirror;
            // To activate the respective toolbar button based on cursor position
        	cm.on("cursorActivity", function() {
        		var stat = getState(cm);

                var buttons = self.querySelectorAll('.toolbar .fa');
                for(var index=0; index < buttons.length; index++) {

                    buttons[index].className = buttons[index].className.replace(/active/g, "");
                }

                var activeButton;
                if(stat.bold) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-bold');
                } else if(stat.italic) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-italic');
                } else if(stat['ordered-list']) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-list-ol');
                } else if(stat['unordered-list']) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-list-ul');
                } else if(stat.heading) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-header');
                } else if(stat.quote) {
                    activeButton = self.querySelector('.toolbar ul li a.fa-quote-left');
                }

                if(activeButton) {
                    activeButton.className = activeButton.className + " active";
                }
        	});
        },
        // Public function for each toolbar items
        handleBold: function() {
            _toggleBlock(this.codemirror, "bold", "**");
        },
        handleItalic: function() {
            _toggleBlock(this.codemirror, "italic", "*")
        },
        handleQuote: function() {
            _toggleLine(this.codemirror, "quote");
        },
        handleOl: function() {
            _toggleLine(this.codemirror, "ordered-list");
        },
        handleUl: function() {
            _toggleLine(this.codemirror, "unordered-list");
        },
        handleHeading: function() {
            _toggleHeading(this.codemirror, "smaller");
        },
        handleLink: function() {
            var stat = getState(this.codemirror);
            var url = "http://";
            url = prompt("URL:", "http://");
            if(!url) {
                return false;
            }
            _replaceSelection(this.codemirror, stat.link, ["[", "](#url#)"], url);
        },
        handleImage: function() {
            var stat = getState(this.codemirror);
            var url = "http://";
            url = prompt("URL of the image:", "http://");
            if(!url) {
                return false;
            }
            _replaceSelection(this.codemirror, stat.image, ["![", "](#url#)"], url);
        },
        handleTable: function() {
            var cm = editor.codemirror;
            var stat = getState(cm);
            var options = editor.options;
            _replaceSelection(cm, stat.table, options.insertTexts.table);
        },
        handlePreview: function() {
            if(this.fullScreenView !== 'full-screen') {
                this.handleExpandOrCollapse();
            }
            this.showPreview = this.showPreview? '': 'show-preview';

            this.updatePreview();
        },
        handleExpandOrCollapse: function() {
            if(this.fullScreenView === 'full-screen') {
                this._collapseFullView();
                this.showPreview = '';
                this.updatePreview();
            } else {
                this.fullScreenView = 'full-screen';
                document.addEventListener('keydown', this._keydownEventHandler);
            }
            this.codemirror.focus();
        },
        _onCaptureKeyDown: function(e) {
            if(e.keyCode === 27) {
                this._collapseFullView();
            }
        },
        _collapseFullView: function() {
            this.fullScreenView = "";
            this.showPreview = '';
            document.removeEventListener('keydown', this._keydownEventHandler);
        },
        replaceSelection: function(text) {
            _replaceSelection(this.codemirror, undefined, [text]);
        }
    });

    function toggleHeadingBigger() {
        _toggleHeading(myCodeMirror, "bigger");
    }

    function drawTable(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        _replaceSelection(cm, stat.table, options.insertTexts.table);
    }

    function drawHorizontalRule(editor) {
        var cm = editor.codemirror;
        var stat = getState(cm);
        var options = editor.options;
        _replaceSelection(cm, stat.image, options.insertTexts.horizontalRule);
    }

    function _replaceSelection(cm, active, startEnd, url) {
        var text;
        var start = startEnd[0];
        var end = startEnd[1];
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        if(url) {
            end = end.replace("#url#", url);
        }
        if(active) {
            text = cm.getLine(startPoint.line);
            start = text.slice(0, startPoint.ch);
            end = text.slice(startPoint.ch);
            cm.replaceRange(start + end, {
                line: startPoint.line,
                ch: 0
            });
        } else {
            text = cm.getSelection();
            cm.replaceSelection(start + text + (end || ''));

            startPoint.ch += start.length;
            if(startPoint !== endPoint) {
                endPoint.ch += start.length;
            }
        }
        cm.setSelection(startPoint, endPoint);
        cm.focus();
    }

    function _toggleBlock(cm, type, start_chars, end_chars) {

        end_chars = (typeof end_chars === "undefined") ? start_chars : end_chars;
        var stat = getState(cm);

        var text;
        var start = start_chars;
        var end = end_chars;

        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");

        if(stat[type]) {
            text = cm.getLine(startPoint.line);
            start = text.slice(0, startPoint.ch);
            end = text.slice(startPoint.ch);
            if(type == "bold") {
                start = start.replace(/(\*\*|__)(?![\s\S]*(\*\*|__))/, "");
                end = end.replace(/(\*\*|__)/, "");
            } else if(type == "italic") {
                start = start.replace(/(\*|_)(?![\s\S]*(\*|_))/, "");
                end = end.replace(/(\*|_)/, "");
            } else if(type == "strikethrough") {
                start = start.replace(/(\*\*|~~)(?![\s\S]*(\*\*|~~))/, "");
                end = end.replace(/(\*\*|~~)/, "");
            }
            cm.replaceRange(start + end, {
                line: startPoint.line,
                ch: 0
            }, {
                line: startPoint.line,
                ch: 99999999999999
            });

            if(type == "bold" || type == "strikethrough") {
                startPoint.ch -= 2;
                if(startPoint !== endPoint) {
                    endPoint.ch -= 2;
                }
            } else if(type == "italic") {
                startPoint.ch -= 1;
                if(startPoint !== endPoint) {
                    endPoint.ch -= 1;
                }
            }
        } else {
            text = cm.getSelection();
            if(type == "bold") {
                text = text.split("**").join("");
                text = text.split("__").join("");
            } else if(type == "italic") {
                text = text.split("*").join("");
                text = text.split("_").join("");
            } else if(type == "strikethrough") {
                text = text.split("~~").join("");
            }
            cm.replaceSelection(start + text + end);

            startPoint.ch += start_chars.length;
            endPoint.ch = startPoint.ch + text.length;
        }

        cm.setSelection(startPoint, endPoint);
        cm.focus();
    }

    function _toggleLine(cm, name) {
        var stat = getState(cm);
        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        var repl = {
            "quote": /^(\s*)\>\s+/,
            "unordered-list": /^(\s*)(\*|\-|\+)\s+/,
            "ordered-list": /^(\s*)\d+\.\s+/
        };
        var map = {
            "quote": "> ",
            "unordered-list": "* ",
            "ordered-list": "1. "
        };
        for(var i = startPoint.line; i <= endPoint.line; i++) {
            (function(i) {
                var text = cm.getLine(i);
                if(stat[name]) {
                    text = text.replace(repl[name], "$1");
                } else {
                    text = map[name] + text;
                }
                cm.replaceRange(text, {
                    line: i,
                    ch: 0
                }, {
                    line: i,
                    ch: 99999999999999
                });
            })(i);
        }
        cm.focus();
    }

    function _toggleHeading(cm, direction, size) {

        var startPoint = cm.getCursor("start");
        var endPoint = cm.getCursor("end");
        for(var i = startPoint.line; i <= endPoint.line; i++) {
            (function(i) {
                var text = cm.getLine(i);
                var currHeadingLevel = text.search(/[^#]/);

                if(direction !== undefined) {
                    if(currHeadingLevel <= 0) {
                        if(direction == "bigger") {
                            text = "###### " + text;
                        } else {
                            text = "# " + text;
                        }
                    } else if(currHeadingLevel == 6 && direction == "smaller") {
                        text = text.substr(7);
                    } else if(currHeadingLevel == 1 && direction == "bigger") {
                        text = text.substr(2);
                    } else {
                        if(direction == "bigger") {
                            text = text.substr(1);
                        } else {
                            text = "#" + text;
                        }
                    }
                } else {
                    if(size == 1) {
                        if(currHeadingLevel <= 0) {
                            text = "# " + text;
                        } else if(currHeadingLevel == size) {
                            text = text.substr(currHeadingLevel + 1);
                        } else {
                            text = "# " + text.substr(currHeadingLevel + 1);
                        }
                    } else if(size == 2) {
                        if(currHeadingLevel <= 0) {
                            text = "## " + text;
                        } else if(currHeadingLevel == size) {
                            text = text.substr(currHeadingLevel + 1);
                        } else {
                            text = "## " + text.substr(currHeadingLevel + 1);
                        }
                    } else {
                        if(currHeadingLevel <= 0) {
                            text = "### " + text;
                        } else if(currHeadingLevel == size) {
                            text = text.substr(currHeadingLevel + 1);
                        } else {
                            text = "### " + text.substr(currHeadingLevel + 1);
                        }
                    }
                }

                cm.replaceRange(text, {
                    line: i,
                    ch: 0
                }, {
                    line: i,
                    ch: 99999999999999
                });
            })(i);
        }
        cm.focus();
    }

    function getState(cm, pos) {
        pos = pos || cm.getCursor("start");
        var stat = cm.getTokenAt(pos);
        if(!stat.type) return {};

        var types = stat.type.split(" ");

        var ret = {},
        data, text;
        for(var i = 0; i < types.length; i++) {
            data = types[i];
            if(data === "strong") {
                ret.bold = true;
            } else if(data === "variable-2") {
                text = cm.getLine(pos.line);
                if(/^\s*\d+\.\s/.test(text)) {
                    ret["ordered-list"] = true;
                } else {
                    ret["unordered-list"] = true;
                }
            } else if(data === "atom") {
                ret.quote = true;
            } else if(data === "em") {
                ret.italic = true;
            } else if(data === "quote") {
                ret.quote = true;
            } else if(data === "strikethrough") {
                ret.strikethrough = true;
            } else if(data === "comment") {
                ret.code = true;
            } else if(data === "link") {
                ret.link = true;
            } else if(data === "tag") {
                ret.image = true;
            } else if(data.match(/^header(\-[1-6])?$/)) {
                ret[data.replace("header", "heading")] = true;
            }
        }
        return ret;
    }
})();
</script>
</dom-module>
